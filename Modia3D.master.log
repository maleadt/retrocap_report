Julia Version 1.4.0
Commit b8e9a9ecc6 (2020-03-21 16:36 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: AMD Ryzen Threadripper 2990WX 32-Core Processor
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-8.0.1 (ORCJIT, znver1)
Environment:
  JULIA_DEPOT_PATH = ::/usr/local/share/julia
  JULIA_NUM_THREADS = 2

  Resolving package versions...
  Installed DataAPI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.1.0
  Installed Reexport â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.2.0
  Installed Missings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.4.3
  Installed RecipesBase â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.8.0
  Installed ConsoleProgressMonitor â”€â”€â”€â”€â”€â”€ v0.1.2
  Installed ConstructionBase â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.0.0
  Installed ChainRulesCore â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.7.1
  Installed Compat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v3.8.0
  Installed ProgressLogging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.1.2
  Installed DiffEqBase â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v6.25.0
  Installed BinaryProvider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.5.8
  Installed DataStructures â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.17.10
  Installed CategoricalArrays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.7.7
    Cloning [82899510-4779-5014-852e-03e436cf321d] IteratorInterfaceExtensions from https://github.com/queryverse/IteratorInterfaceExtensions.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed IteratorInterfaceExtensions â”€ v1.0.0
    Cloning [07f2c1e0-90b0-56cf-bda7-b44b56e34eed] Modia3D from https://github.com/ModiaSim/Modia3D.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed Modia3D â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.4.0
    Cloning [2dfb63ee-cc39-5dd5-95bd-886bf059d720] PooledArrays from https://github.com/JuliaData/PooledArrays.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed PooledArrays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.5.3
    Cloning [700de1a5-db45-46bc-99cf-38207098b444] ZygoteRules from https://github.com/FluxML/ZygoteRules.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed ZygoteRules â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.2.0
    Cloning [bd369af6-aec1-5ad0-b16a-f7cc5008161c] Tables from https://github.com/JuliaData/Tables.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed Tables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.0.3
    Cloning [ae029012-a4dd-5104-9daa-d747884805df] Requires from https://github.com/MikeInnes/Requires.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed Requires â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.0.1
    Cloning [1d6d02ad-be62-4b6b-8a6d-2f90e265016e] LeftChildRightSiblingTrees from https://github.com/JuliaCollections/LeftChildRightSiblingTrees.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed LeftChildRightSiblingTrees â”€â”€ v0.1.2
    Cloning [bac558e1-5e72-5ebc-8fee-abe8a469f55d] OrderedCollections from https://github.com/JuliaCollections/OrderedCollections.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed OrderedCollections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.1.0
    Cloning [1986cc42-f94f-5a68-af5c-568840ba703d] Unitful from https://github.com/PainterQubits/Unitful.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed Unitful â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.0.0
    Cloning [69de0a69-1ddd-5017-9359-2bf0b02dc9f0] Parsers from https://github.com/JuliaData/Parsers.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed Parsers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.3.12
    Cloning [42fd0dbc-a981-5370-80f2-aaf504508153] IterativeSolvers from https://github.com/JuliaMath/IterativeSolvers.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed IterativeSolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.8.3
    Cloning [a2af1166-a08f-5f64-846c-94a0d3cef48c] SortingAlgorithms from https://github.com/JuliaCollections/SortingAlgorithms.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed SortingAlgorithms â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.3.1
    Cloning [f2b01f46-fcfa-551c-844a-d8ac1e96c665] Roots from https://github.com/JuliaMath/Roots.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed Roots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.0.1
    Cloning [e2d170a0-9d28-54be-80f0-106bbe20a464] DataValueInterfaces from https://github.com/queryverse/DataValueInterfaces.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed DataValueInterfaces â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.0.0
    Cloning [46d2c3a1-f734-5fdb-9937-b9b9aeba4221] MuladdMacro from https://github.com/JuliaDiffEq/MuladdMacro.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed MuladdMacro â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.2.2
    Cloning [a2a6695c-b41b-5b7d-aed9-dbfdeacea5d7] TreeViews from https://github.com/pfitzseb/TreeViews.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed TreeViews â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.3.0
    Cloning [1520ce14-60c1-5f80-bbc7-55ef81b5835c] AbstractTrees from https://github.com/JuliaCollections/AbstractTrees.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed AbstractTrees â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.3.2
    Cloning [4fba245c-0d91-5ea0-9b3e-6abc04ee57a9] ArrayInterface from https://github.com/JuliaDiffEq/ArrayInterface.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed ArrayInterface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v2.6.1
    Cloning [1914dd2f-81c6-5fcd-8719-6d5c9610ff09] MacroTools from https://github.com/MikeInnes/MacroTools.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed MacroTools â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.5.5
    Cloning [5d786b92-1e48-4d6f-9151-6b4477ca9bed] TerminalLoggers from https://github.com/c42f/TerminalLoggers.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed TerminalLoggers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.1.1
    Cloning [a93c6f00-e57d-5684-b7b6-d8193f3e46c0] DataFrames from https://github.com/JuliaData/DataFrames.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed DataFrames â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.20.2
    Cloning [67ccffd1-116d-535b-ad39-76a8fd0cbf71] ModiaMath from https://github.com/ModiaSim/ModiaMath.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed ModiaMath â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.5.2
    Cloning [41ab1584-1d38-5bbf-9106-f11c6c58b48f] InvertedIndices from https://github.com/mbauman/InvertedIndices.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed InvertedIndices â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.0.0
    Cloning [e6f89c97-d47a-5376-807f-9c37f3926c36] LoggingExtras from https://github.com/oxinabox/LoggingExtras.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed LoggingExtras â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.4.0
    Cloning [069b7b12-0de2-55c6-9aab-29f3d0a68a2e] FunctionWrappers from https://github.com/yuyichao/FunctionWrappers.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed FunctionWrappers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.1.1
    Cloning [ffbed154-4ef7-542d-bbb7-c09d3a79fcae] DocStringExtensions from https://github.com/JuliaDocs/DocStringExtensions.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed DocStringExtensions â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.8.1
    Cloning [f2c3362d-daeb-58d1-803e-2bc74f2840b4] RecursiveFactorization from https://github.com/YingboMa/RecursiveFactorization.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed RecursiveFactorization â”€â”€â”€â”€â”€â”€ v0.1.0
    Cloning [90137ffa-7385-5640-81b9-e52037218182] StaticArrays from https://github.com/JuliaArrays/StaticArrays.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed StaticArrays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.12.1
    Cloning [682c06a0-de6a-54ab-a142-c8b1cf79cde6] JSON from https://github.com/JuliaIO/JSON.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed JSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.21.0
    Cloning [d96e819e-fc66-5662-9728-84c9c7592b0a] Parameters from https://github.com/mauro3/Parameters.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed Parameters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.12.0
    Cloning [c3572dad-4567-51f8-b174-8c6c989267f4] Sundials from https://github.com/JuliaDiffEq/Sundials.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed Sundials â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v3.9.0
    Cloning [3783bdb8-4a98-5b6b-af9a-565f29a5fe9c] TableTraits from https://github.com/queryverse/TableTraits.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed TableTraits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.0.0
    Cloning [92933f4c-e287-5a05-a399-4b506db050ca] ProgressMeter from https://github.com/timholy/ProgressMeter.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed ProgressMeter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.2.0
    Cloning [731186ca-8d62-57ce-b412-fbd966d074cd] RecursiveArrayTools from https://github.com/JuliaDiffEq/RecursiveArrayTools.jl.git
[?25l    Fetching: [>                                        ]  0.0 %[2K[?25h  Installed RecursiveArrayTools â”€â”€â”€â”€â”€â”€â”€â”€â”€ v2.1.0
   Updating `~/.julia/environments/v1.4/Project.toml`
  [07f2c1e0] + Modia3D v0.4.0
   Updating `~/.julia/environments/v1.4/Manifest.toml`
  [1520ce14] + AbstractTrees v0.3.2
  [4fba245c] + ArrayInterface v2.6.1
  [b99e7846] + BinaryProvider v0.5.8
  [324d7699] + CategoricalArrays v0.7.7
  [d360d2e6] + ChainRulesCore v0.7.1
  [34da2185] + Compat v3.8.0
  [88cd18e8] + ConsoleProgressMonitor v0.1.2
  [187b0558] + ConstructionBase v1.0.0
  [9a962f9c] + DataAPI v1.1.0
  [a93c6f00] + DataFrames v0.20.2
  [864edb3b] + DataStructures v0.17.10
  [e2d170a0] + DataValueInterfaces v1.0.0
  [2b5f629d] + DiffEqBase v6.25.0
  [ffbed154] + DocStringExtensions v0.8.1
  [069b7b12] + FunctionWrappers v1.1.1
  [41ab1584] + InvertedIndices v1.0.0
  [42fd0dbc] + IterativeSolvers v0.8.3
  [82899510] + IteratorInterfaceExtensions v1.0.0
  [682c06a0] + JSON v0.21.0
  [1d6d02ad] + LeftChildRightSiblingTrees v0.1.2
  [e6f89c97] + LoggingExtras v0.4.0
  [1914dd2f] + MacroTools v0.5.5
  [e1d29d7a] + Missings v0.4.3
  [07f2c1e0] + Modia3D v0.4.0
  [67ccffd1] + ModiaMath v0.5.2
  [46d2c3a1] + MuladdMacro v0.2.2
  [bac558e1] + OrderedCollections v1.1.0
  [d96e819e] + Parameters v0.12.0
  [69de0a69] + Parsers v0.3.12
  [2dfb63ee] + PooledArrays v0.5.3
  [33c8b6b6] + ProgressLogging v0.1.2
  [92933f4c] + ProgressMeter v1.2.0
  [3cdcf5f2] + RecipesBase v0.8.0
  [731186ca] + RecursiveArrayTools v2.1.0
  [f2c3362d] + RecursiveFactorization v0.1.0
  [189a3867] + Reexport v0.2.0
  [ae029012] + Requires v1.0.1
  [f2b01f46] + Roots v1.0.1
  [a2af1166] + SortingAlgorithms v0.3.1
  [90137ffa] + StaticArrays v0.12.1
  [c3572dad] + Sundials v3.9.0
  [3783bdb8] + TableTraits v1.0.0
  [bd369af6] + Tables v1.0.3
  [5d786b92] + TerminalLoggers v0.1.1
  [a2a6695c] + TreeViews v0.3.0
  [1986cc42] + Unitful v1.0.0
  [700de1a5] + ZygoteRules v0.2.0
  [2a0f44e3] + Base64 
  [ade2ca70] + Dates 
  [8bb1440f] + DelimitedFiles 
  [8ba89e20] + Distributed 
  [9fa8497b] + Future 
  [b77e0a4c] + InteractiveUtils 
  [76f85450] + LibGit2 
  [8f399da3] + Libdl 
  [37e2e46d] + LinearAlgebra 
  [56ddb016] + Logging 
  [d6f4376e] + Markdown 
  [a63ad114] + Mmap 
  [44cfe95a] + Pkg 
  [de0858da] + Printf 
  [3fa0cd96] + REPL 
  [9a3f8284] + Random 
  [ea8e919c] + SHA 
  [9e88b42a] + Serialization 
  [1a1011a3] + SharedArrays 
  [6462fe0b] + Sockets 
  [2f01184e] + SparseArrays 
  [10745b16] + Statistics 
  [4607b0f0] + SuiteSparse 
  [8dfed614] + Test 
  [cf7118a7] + UUIDs 
  [4ec0a83e] + Unicode 
   Building Sundials â†’ `~/.julia/packages/Sundials/S5Ws7/deps/build.log`
    Testing Modia3D
Status `/tmp/jl_F6OptB/Manifest.toml`
  [1520ce14] AbstractTrees v0.3.2
  [4fba245c] ArrayInterface v2.6.1
  [b99e7846] BinaryProvider v0.5.8
  [324d7699] CategoricalArrays v0.7.7
  [d360d2e6] ChainRulesCore v0.7.1
  [34da2185] Compat v3.8.0
  [88cd18e8] ConsoleProgressMonitor v0.1.2
  [187b0558] ConstructionBase v1.0.0
  [9a962f9c] DataAPI v1.1.0
  [a93c6f00] DataFrames v0.20.2
  [864edb3b] DataStructures v0.17.10
  [e2d170a0] DataValueInterfaces v1.0.0
  [2b5f629d] DiffEqBase v6.25.0
  [ffbed154] DocStringExtensions v0.8.1
  [069b7b12] FunctionWrappers v1.1.1
  [41ab1584] InvertedIndices v1.0.0
  [42fd0dbc] IterativeSolvers v0.8.3
  [82899510] IteratorInterfaceExtensions v1.0.0
  [682c06a0] JSON v0.21.0
  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2
  [e6f89c97] LoggingExtras v0.4.0
  [1914dd2f] MacroTools v0.5.5
  [e1d29d7a] Missings v0.4.3
  [07f2c1e0] Modia3D v0.4.0
  [67ccffd1] ModiaMath v0.5.2
  [46d2c3a1] MuladdMacro v0.2.2
  [bac558e1] OrderedCollections v1.1.0
  [d96e819e] Parameters v0.12.0
  [69de0a69] Parsers v0.3.12
  [2dfb63ee] PooledArrays v0.5.3
  [33c8b6b6] ProgressLogging v0.1.2
  [92933f4c] ProgressMeter v1.2.0
  [3cdcf5f2] RecipesBase v0.8.0
  [731186ca] RecursiveArrayTools v2.1.0
  [f2c3362d] RecursiveFactorization v0.1.0
  [189a3867] Reexport v0.2.0
  [ae029012] Requires v1.0.1
  [f2b01f46] Roots v1.0.1
  [a2af1166] SortingAlgorithms v0.3.1
  [90137ffa] StaticArrays v0.12.1
  [c3572dad] Sundials v3.9.0
  [3783bdb8] TableTraits v1.0.0
  [bd369af6] Tables v1.0.3
  [5d786b92] TerminalLoggers v0.1.1
  [a2a6695c] TreeViews v0.3.0
  [1986cc42] Unitful v1.0.0
  [700de1a5] ZygoteRules v0.2.0
  [2a0f44e3] Base64 
  [ade2ca70] Dates 
  [8bb1440f] DelimitedFiles 
  [8ba89e20] Distributed 
  [9fa8497b] Future 
  [b77e0a4c] InteractiveUtils 
  [76f85450] LibGit2 
  [8f399da3] Libdl 
  [37e2e46d] LinearAlgebra 
  [56ddb016] Logging 
  [d6f4376e] Markdown 
  [a63ad114] Mmap 
  [44cfe95a] Pkg 
  [de0858da] Printf 
  [3fa0cd96] REPL 
  [9a3f8284] Random 
  [ea8e919c] SHA 
  [9e88b42a] Serialization 
  [1a1011a3] SharedArrays 
  [6462fe0b] Sockets 
  [2f01184e] SparseArrays 
  [10745b16] Statistics 
  [4607b0f0] SuiteSparse 
  [8dfed614] Test 
  [cf7118a7] UUIDs 
  [4ec0a83e] Unicode 

Importing Modia3D Version 0.4.0 (2019-09-27)
 
Importing ModiaMath Version 0.5.2 (2019-07-10)
    PyPlot not available (plot commands will be ignored).
    Try to install PyPlot. See hints here:
    https://github.com/ModiaSim/ModiaMath.jl/wiki/Installing-PyPlot-in-a-robust-way.
â”Œ Warning: 
â”‚ Environment variable "DLR_VISUALIZATION" not defined.
â”‚ Include ENV["DLR_VISUALIZATION"] = <path-to-Visualization/Extras/SimVis> into your HOME/.julia/config/startup.jl file.
â”‚ 
â”‚ No Renderer is used in Modia3D (so, animation is switched off).
â”” @ Modia3D.DLR_Visualization ~/.julia/packages/Modia3D/r9s9x/src/renderer/DLR_Visualization/renderer.jl:87
... success of test_solidProperties.jl!
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: Pendulum
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name    â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ rev.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2 â”‚ rev.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      Simulation is terminated at time = 4.5 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 4.9 s (init: 4.2 s, integration: 0.62 s)
        startTime      = 0.0 s
        stopTime       = 4.5 s
        interval       = 0.002 s
        tolerance      = 1.0e-6
        nEquations     = 2 (includes 0 constraints)
        nResults       = 2251
        nSteps         = 272
        nResidues      = 339 (includes residue calls for Jacobian)
        nZeroCrossings = 0
        nJac           = 26
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 2
        h0             = 5.8e-09 s
        hMin           = 5.8e-09 s
        hMax           = 0.021 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_Pendulum.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_DoublePendulum.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_ControllerDamper.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_DamperMacro.jl!
... Revolute joint connecting Fourbar.bar3.frame2 with Fourbar.bar2.frame2 is a cut-joint

... Cut-joint rev4 pushed on scene.cutJoints vector
... success of Simulate_FourBar.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... pos_angle2(time=0.5) = 2.24
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: Pendulum
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name    â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ rev.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2 â”‚ rev.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      Simulation is terminated at time = 4.5 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.043 s (init: 0.00075 s, integration: 0.042 s)
        startTime      = 0.0 s
        stopTime       = 4.5 s
        interval       = 0.002 s
        tolerance      = 1.0e-6
        nEquations     = 2 (includes 0 constraints)
        nResults       = 2251
        nSteps         = 206
        nResidues      = 267 (includes residue calls for Jacobian)
        nZeroCrossings = 0
        nJac           = 23
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 2
        h0             = 1.2e-08 s
        hMin           = 1.2e-08 s
        hMax           = 0.049 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_PendulumWithFixedJoint.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_2Rev_ZylZ_BarX.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_3Rev_ZylZ_BarX_BarY.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_InertiaTensor.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_KinematicRevoluteJoints.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_Dynamic_Pendulum_xAxis.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_Dynamic_Pendulum_yAxis.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_Dynamic_Pendulum_zAxis.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_Prismatic_xAxis.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_Prismatic_yAxis.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_Prismatic_zAxis.jl!
... Revolute joint connecting Fourbar.bar3.frame2 with Fourbar.bar2.frame2 is a cut-joint

... Cut-joint fourbar.rev4 pushed on scene.cutJoints vector
... success of Move_FourBar_xAxis.jl!
... Revolute joint connecting Fourbar.bar3.frame2 with Fourbar.bar2.frame2 is a cut-joint

... Cut-joint fourbar.rev4 pushed on scene.cutJoints vector
... success of Move_FourBar_yAxis.jl!
... Revolute joint connecting Fourbar.bar3.frame2 with Fourbar.bar2.frame2 is a cut-joint

... Cut-joint fourbar.rev4 pushed on scene.cutJoints vector
... success of Move_FourBar_zAxis.jl!
... Revolute joint connecting Fourbar.bar3.frame2 with Fourbar.bar2.frame2 is a cut-joint

... Cut-joint rev4 pushed on scene.cutJoints vector
... success of Move_FourBar_noMacros.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of test_massComputation.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_Signal1Assembly.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_Signal4Assemblies.jl!
WARNING: replacing module test_massComputation.
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of test_massComputation.jl!
... success of volume_computation3D_obj.jl!
initAnalysis!(world::Object3D, scene::Scene)
... success of Move_Pendulum.jl!
initAnalysis!(world::Object3D, scene::Scene)
... success of Visualize_Beam.jl!

 ...test_Examples finished!
WARNING: replacing module TestExamples.
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of examples/collisions/Simulate_Billiards_OneBall!
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: BouncingBall1
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name   â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ h      â”‚ 0.2     â”‚ 0     â”‚ 0.2     â”‚
          â”‚ 2 â”‚ v      â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚

... h0 = 0.2
        flying = true
        -h = -0.2 (became <= 0)
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      State event (zero-crossing) at time = 0.2019275108811498 s (z[1] > 0)
        -h = 1.6181500583911657e-14 (became > 0)
... v = 1.3866362172208557
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 0.484626025952448 s (z[1] > 0)
        -h = 2.71657696337968e-14 (became > 0)
... v = 0.9706453509400057
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 0.682514985967628 s (z[1] > 0)
        -h = 1.3320941572025902e-14 (became > 0)
... v = 0.6794517427662368
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 0.8210372566626214 s (z[1] > 0)
        -h = 6.938893903907228e-18 (became > 0)
... v = 0.47561621292614215
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 0.9180028433604212 s (z[1] > 0)
        -h = 2.3418766925686896e-17 (became > 0)
... v = 0.3329313347031544
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 0.9858787506124347 s (z[1] > 0)
        -h = 3.80034545499619e-15 (became > 0)
... v = 0.23305186965963645
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      Simulation is terminated at time = 1.0 s

      BouncingBall model is terminated (flying = true)

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.53 s (init: 0.42 s, integration: 0.11 s)
        startTime      = 0.0 s
        stopTime       = 1.0 s
        interval       = 0.02 s
        tolerance      = 0.0001
        nEquations     = 2 (includes 0 constraints)
        nResults       = 63
        nSteps         = 125
        nResidues      = 345 (includes residue calls for Jacobian)
        nZeroCrossings = 237
        nJac           = 110
        nTimeEvents    = 0
        nStateEvents   = 6
        nRestartEvents = 6
        nErrTestFails  = 0
        h0             = 7.2e-07 s
        hMin           = 7.2e-07 s
        hMax           = 0.27 s
        orderMax       = 3
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of examples/collisions/Simulate_BouncingBall.jl
... success of examples/collisions/Simulate_NewtonsCradle.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of examples/collisions/Simulate_SlidingAndRollingBall.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of examples/collisions/Simulate_TwoCollidingBalls.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: YouBot
      Initialization at time = 0.0 s
        initial values:
          â”‚ x  â”‚ name                          â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1  â”‚ link1.rev.rev.phi             â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2  â”‚ link1.rev.controller.PI_x     â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 3  â”‚ link2.rev.rev.phi             â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 4  â”‚ link2.rev.controller.PI_x     â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 5  â”‚ link3.rev.rev.phi             â”‚ 1.5708  â”‚ 1     â”‚ 1.5708  â”‚
          â”‚ 6  â”‚ link3.rev.controller.PI_x     â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 7  â”‚ link4.rev.rev.phi             â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 8  â”‚ link4.rev.controller.PI_x     â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 9  â”‚ link5.rev.rev.phi             â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 10 â”‚ link5.rev.controller.PI_x     â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 11 â”‚ gripper.prism.prism.s         â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 12 â”‚ gripper.prism.controller.PI_x â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 13 â”‚ sphere.r[1]                   â”‚ -0.125  â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 14 â”‚ sphere.r[2]                   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 15 â”‚ sphere.r[3]                   â”‚ 0.03    â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 16 â”‚ link1.rev.rev.w               â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 17 â”‚ link2.rev.rev.w               â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 18 â”‚ link3.rev.rev.w               â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 19 â”‚ link4.rev.rev.w               â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 20 â”‚ link5.rev.rev.w               â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 21 â”‚ gripper.prism.prism.v         â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 22 â”‚ sphere.v[1]                   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 23 â”‚ sphere.v[2]                   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 24 â”‚ sphere.v[3]                   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 25 â”‚ sphere.q[1]                   â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 26 â”‚ sphere.q[2]                   â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 27 â”‚ sphere.q[3]                   â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 28 â”‚ sphere.q[4]                   â”‚ 1.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 29 â”‚ sphere.w[1]                   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 30 â”‚ sphere.w[2]                   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 31 â”‚ sphere.w[3]                   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
      Simulation started

      State event (zero-crossing) at time = 7.261196339086959e-5 s (z[2] < 0)
        distance(table.plate,sphere) = -2.000000003744737e-8 became < 0
            contact normal = [4.51e-08,6.28e-08,1], contact position = [0.585,-1.57e-09,0.375], c_res=1.24e+06, d_res=1e+03
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.4173138190720484 s (z[2] < 0)
        distance(sphere,gripper.gripper_right_finger) = -2.00000000311071e-8 became < 0
            contact normal = [-1,-0.00507,-2.05e-05], contact position = [0.56,-0.000127,0.4], c_res=1.24e+06, d_res=9.39
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.4173142226300906 s (z[2] < 0)
        distance(sphere,gripper.gripper_left_finger) = -2.0000005203777326e-8 became < 0
            contact normal = [-1,0.00702,2.02e-05], contact position = [0.56,0.000175,0.4], c_res=1.24e+06, d_res=9.39
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.42197539377478954 s (z[1] > 0)
        distance(sphere,gripper.gripper_left_finger)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.42197622471964996 s (z[1] > 0)
        distance(sphere,gripper.gripper_right_finger)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart
      progress: integrated up to time = 0.45 s
      progress: integrated up to time = 2.2 s
      progress: integrated up to time = 2.4 s
      progress: integrated up to time = 2.5 s
      progress: integrated up to time = 2.6 s
      progress: integrated up to time = 2.7 s
      progress: integrated up to time = 3.4 s
      progress: integrated up to time = 3.4 s
      progress: integrated up to time = 3.5 s
      progress: integrated up to time = 3.5 s
      progress: integrated up to time = 3.5 s
      progress: integrated up to time = 3.5 s
      progress: integrated up to time = 3.5 s

      State event (zero-crossing) at time = 3.5455247283137004 s (z[1] > 0)
        distance(table.plate,sphere)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.7727563190722595 s (z[2] < 0)
        distance(ground,sphere) = -2.0000000291009164e-8 became < 0
            contact normal = [-5.5e-07,-3e-06,1], contact position = [0.939,-0.000237,-3.46e-06], c_res=1.24e+06, d_res=0.32
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.787773112741333 s (z[1] > 0)
        distance(ground,sphere)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart
      progress: integrated up to time = 3.9 s

      State event (zero-crossing) at time = 4.126292230260283 s (z[2] < 0)
        distance(ground,sphere) = -2.0000076375351717e-8 became < 0
            contact normal = [-5.51e-07,-3e-06,1], contact position = [1.03,-0.000263,-3.4e-06], c_res=1.24e+06, d_res=0.519
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 4.142992747657511 s (z[1] > 0)
        distance(ground,sphere)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 4.347794624886097 s (z[2] < 0)
        distance(ground,sphere) = -2.000004881590844e-8 became < 0
            contact normal = [-5.52e-07,-3e-06,1], contact position = [1.09,-0.00028,-3.37e-06], c_res=1.24e+06, d_res=0.858
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 4.366594002719718 s (z[1] > 0)
        distance(ground,sphere)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 4.485882523162501 s (z[2] < 0)
        distance(ground,sphere) = -2.0000000129068757e-8 became < 0
            contact normal = [-5.53e-07,-2.99e-06,1], contact position = [1.13,-0.000291,-3.34e-06], c_res=1.24e+06, d_res=1.47
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 4.507636539428118 s (z[1] > 0)
        distance(ground,sphere)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 4.571091127968425 s (z[2] < 0)
        distance(ground,sphere) = -2.0000014251610404e-8 became < 0
            contact normal = [-5.53e-07,-2.99e-06,1], contact position = [1.15,-0.000298,-3.33e-06], c_res=1.24e+06, d_res=2.77
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 4.598491419368954 s (z[1] > 0)
        distance(ground,sphere)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 4.622010551101191 s (z[2] < 0)
        distance(ground,sphere) = -2.0000004512420127e-8 became < 0
            contact normal = [-5.53e-07,-2.99e-06,1], contact position = [1.17,-0.000302,-3.32e-06], c_res=1.24e+06, d_res=7.53
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      Simulation is terminated at time = 5.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 77 s (init: 0.097 s, integration: 77 s)
        startTime      = 0.0 s
        stopTime       = 5.0 s
        interval       = 0.001 s
        tolerance      = 1.0e-5
        nEquations     = 31 (includes 1 constraints)
        nResults       = 5035
        nSteps         = 6081
        nResidues      = 144167 (includes residue calls for Jacobian)
        nZeroCrossings = 11244
        nJac           = 4227
        nTimeEvents    = 0
        nStateEvents   = 17
        nRestartEvents = 17
        nErrTestFails  = 1709
        h0             = 7.3e-09 s
        hMin           = 7.3e-09 s
        hMax           = 0.053 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of examples/collisions/Simulate_YouBot.jl
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Collision_3Elements.jl!
... success of Test_Collision.jl!
... success of Test_Collision_moreRevolutes.jl!
... success of Test_Collision_StarSetting.jl!
... success of Test_MiniBsp.jl!
... success of Test_Solids.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_ContactBoxOnTable.jl!
WARNING: replacing module Simulate_YouBot.
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_YouBotBoxOnTable.jl!
... success of collision_2_boxes.jl!
... success of collision_ballWithBall.jl!
... success of collision_ballWithBox.jl!
... success of collision_ballWithBox_45Deg.jl!
... success of collision_BallWithBox_Prismatic.jl!
WARNING: replacing module collision_ballWithBox_45Deg.
... success of collision_ballWithBox_45Deg.jl!
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: NewtonsCradle
      Initialization at time = 0.0 s
        initial values:
          â”‚ x  â”‚ name     â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1  â”‚ rev1.phi â”‚ -1.0472 â”‚ 1     â”‚ 1.0472  â”‚
          â”‚ 2  â”‚ rev2.phi â”‚ -1.0472 â”‚ 1     â”‚ 1.0472  â”‚
          â”‚ 3  â”‚ rev3.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 4  â”‚ rev4.phi â”‚ 1.0472  â”‚ 1     â”‚ 1.0472  â”‚
          â”‚ 5  â”‚ rev5.phi â”‚ 1.0472  â”‚ 1     â”‚ 1.0472  â”‚
          â”‚ 6  â”‚ rev1.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 7  â”‚ rev2.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 8  â”‚ rev3.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 9  â”‚ rev4.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 10 â”‚ rev5.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      State event (zero-crossing) at time = 1.0878031474718333 s (z[2] < 0)
        distance(pendulum4.sphere,pendulum3.sphere) = -2.0000077594062304e-8 became < 0
            contact normal = [0,-1,-0.000313], contact position = [0,0.5,-4], c_res=1.1e+11, d_res=0.11
        distance(pendulum3.sphere,pendulum2.sphere) = -2.0000077260995397e-8 became < 0
            contact normal = [0,-1,0.000313], contact position = [0,-0.5,-4], c_res=1.1e+11, d_res=0.11
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 1.0908094518650024 s (z[1] > 0)
        distance(pendulum4.sphere,pendulum3.sphere)  became > 0
        distance(pendulum3.sphere,pendulum2.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 1.0938480230542378 s (z[2] < 0)
        distance(pendulum1.sphere,pendulum2.sphere) = -2.0000232248129635e-8 became < 0
            contact normal = [0,1,-0.000784], contact position = [0,-1.51,-4], c_res=1.1e+11, d_res=0.0667
        distance(pendulum5.sphere,pendulum4.sphere) = -2.000023202608503e-8 became < 0
            contact normal = [0,-1,-0.000784], contact position = [0,1.51,-4], c_res=1.1e+11, d_res=0.0667
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 1.0958883290568509 s (z[1] > 0)
        distance(pendulum1.sphere,pendulum2.sphere)  became > 0
        distance(pendulum5.sphere,pendulum4.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 1.0985275695684327 s (z[2] < 0)
        distance(pendulum4.sphere,pendulum3.sphere) = -2.0000000211517488e-8 became < 0
            contact normal = [0,-1,-0.000313], contact position = [0,0.5,-4], c_res=1.1e+11, d_res=0.169
        distance(pendulum3.sphere,pendulum2.sphere) = -1.9999999101294463e-8 became < 0
            contact normal = [0,-1,0.000313], contact position = [0,-0.5,-4], c_res=1.1e+11, d_res=0.169
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 1.1018053667261674 s (z[1] > 0)
        distance(pendulum4.sphere,pendulum3.sphere)  became > 0
        distance(pendulum3.sphere,pendulum2.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 3.1750114228447495 s (z[2] < 0)
        distance(pendulum4.sphere,pendulum3.sphere) = -1.9999989109287242e-8 became < 0
            contact normal = [0,-1,-0.000313], contact position = [0,0.5,-4], c_res=1.1e+11, d_res=0.262
        distance(pendulum3.sphere,pendulum2.sphere) = -2.0000000766629e-8 became < 0
            contact normal = [0,-1,0.000313], contact position = [0,-0.5,-4], c_res=1.1e+11, d_res=0.262
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 3.1785879880615164 s (z[1] > 0)
        distance(pendulum4.sphere,pendulum3.sphere)  became > 0
        distance(pendulum3.sphere,pendulum2.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 3.1930977548240014 s (z[2] < 0)
        distance(pendulum1.sphere,pendulum2.sphere) = -2.0000009426368592e-8 became < 0
            contact normal = [0,1,-0.00063], contact position = [0,-1.52,-4], c_res=1.1e+11, d_res=0.147
        distance(pendulum5.sphere,pendulum4.sphere) = -2.0000012757037666e-8 became < 0
            contact normal = [0,-1,-0.00063], contact position = [0,1.52,-4], c_res=1.1e+11, d_res=0.147
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 3.1954887018752087 s (z[1] > 0)
        distance(pendulum1.sphere,pendulum2.sphere)  became > 0
        distance(pendulum5.sphere,pendulum4.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 3.2073414785973235 s (z[2] < 0)
        distance(pendulum4.sphere,pendulum3.sphere) = -1.999992316203958e-8 became < 0
            contact normal = [0,-1,-0.000313], contact position = [0,0.5,-4], c_res=1.1e+11, d_res=0.347
        distance(pendulum3.sphere,pendulum2.sphere) = -2.0000000100495186e-8 became < 0
            contact normal = [0,-1,0.000313], contact position = [0,-0.5,-4], c_res=1.1e+11, d_res=0.347
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 3.211125697316102 s (z[1] > 0)
        distance(pendulum4.sphere,pendulum3.sphere)  became > 0
        distance(pendulum3.sphere,pendulum2.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 5.306987610498805 s (z[2] < 0)
        distance(pendulum4.sphere,pendulum3.sphere) = -2.0000038292167233e-8 became < 0
            contact normal = [0,-1,-0.000313], contact position = [0,0.5,-4], c_res=1.1e+11, d_res=0.537
        distance(pendulum3.sphere,pendulum2.sphere) = -1.9998782851970986e-8 became < 0
            contact normal = [0,-1,0.000313], contact position = [0,-0.5,-4], c_res=1.1e+11, d_res=0.537
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 5.311116540157841 s (z[1] > 0)
        distance(pendulum4.sphere,pendulum3.sphere)  became > 0
        distance(pendulum3.sphere,pendulum2.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 5.3389794846640575 s (z[2] < 0)
        distance(pendulum1.sphere,pendulum2.sphere) = -2.0000039291367955e-8 became < 0
            contact normal = [0,1,-0.00065], contact position = [0,-1.52,-4], c_res=1.1e+11, d_res=0.336
        distance(pendulum5.sphere,pendulum4.sphere) = -1.99989548255175e-8 became < 0
            contact normal = [0,-1,-0.00065], contact position = [0,1.52,-4], c_res=1.1e+11, d_res=0.336
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 5.341800682588432 s (z[1] > 0)
        distance(pendulum1.sphere,pendulum2.sphere)  became > 0
        distance(pendulum5.sphere,pendulum4.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 5.371038706105848 s (z[2] < 0)
        distance(pendulum4.sphere,pendulum3.sphere) = -2.0000006983877938e-8 became < 0
            contact normal = [0,-1,-0.000313], contact position = [0,0.5,-4], c_res=1.1e+11, d_res=0.886
        distance(pendulum3.sphere,pendulum2.sphere) = -1.9988123378666955e-8 became < 0
            contact normal = [0,-1,0.000313], contact position = [0,-0.5,-4], c_res=1.1e+11, d_res=0.886
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 5.375601280236619 s (z[1] > 0)
        distance(pendulum4.sphere,pendulum3.sphere)  became > 0
        distance(pendulum3.sphere,pendulum2.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 7.586849755374663 s (z[2] < 0)
        distance(pendulum4.sphere,pendulum3.sphere) = -1.9609640355966462e-8 became < 0
            contact normal = [0,-1,-0.000313], contact position = [0,0.5,-4], c_res=1.1e+11, d_res=1.37
        distance(pendulum3.sphere,pendulum2.sphere) = -2.0000080924731378e-8 became < 0
            contact normal = [0,-1,0.000313], contact position = [0,-0.5,-4], c_res=1.1e+11, d_res=1.37
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 7.591827089433919 s (z[1] > 0)
        distance(pendulum4.sphere,pendulum3.sphere)  became > 0
        distance(pendulum3.sphere,pendulum2.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 7.623516942618943 s (z[2] < 0)
        distance(pendulum1.sphere,pendulum2.sphere) = -1.96331674251482e-8 became < 0
            contact normal = [0,1,-0.000809], contact position = [0,-1.51,-4], c_res=1.1e+11, d_res=0.73
        distance(pendulum5.sphere,pendulum4.sphere) = -2.0000000100495186e-8 became < 0
            contact normal = [0,-1,-0.000809], contact position = [0,1.51,-4], c_res=1.1e+11, d_res=0.73
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 7.626809172298678 s (z[1] > 0)
        distance(pendulum1.sphere,pendulum2.sphere)  became > 0
        distance(pendulum5.sphere,pendulum4.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 7.651102476406292 s (z[2] < 0)
        distance(pendulum4.sphere,pendulum3.sphere) = -1.694994378187431e-8 became < 0
            contact normal = [0,-1,-0.000313], contact position = [0,0.5,-4], c_res=1.1e+11, d_res=1.68
        distance(pendulum3.sphere,pendulum2.sphere) = -2.0000034739453554e-8 became < 0
            contact normal = [0,-1,0.000313], contact position = [0,-0.5,-4], c_res=1.1e+11, d_res=1.68
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 7.656286321908144 s (z[1] > 0)
        distance(pendulum4.sphere,pendulum3.sphere)  became > 0
        distance(pendulum3.sphere,pendulum2.sphere)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      Simulation is terminated at time = 10.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 1.9 s (init: 0.0021 s, integration: 1.9 s)
        startTime      = 0.0 s
        stopTime       = 10.0 s
        interval       = 0.001 s
        tolerance      = 1.0e-8
        nEquations     = 10 (includes 0 constraints)
        nResults       = 10049
        nSteps         = 3394
        nResidues      = 11111 (includes residue calls for Jacobian)
        nZeroCrossings = 13578
        nJac           = 644
        nTimeEvents    = 0
        nStateEvents   = 24
        nRestartEvents = 24
        nErrTestFails  = 183
        h0             = 3.7e-10 s
        hMin           = 3.7e-10 s
        hMax           = 0.046 s
        orderMax       = 5
        sparseSolver   = false
... success of collision_newtons_cradle.jl!


variables: . Omitted printing of 12 columns
â”‚ Row â”‚ name                â”‚ ValueType                    â”‚ unit    â”‚
â”‚     â”‚ Symbol              â”‚ Symbol                       â”‚ String  â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time                â”‚ Float64                      â”‚ s       â”‚
â”‚ 2   â”‚ boxMoving.r         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m       â”‚
â”‚ 3   â”‚ boxMoving.v         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m/s     â”‚
â”‚ 4   â”‚ boxMoving.a         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m/s^2   â”‚
â”‚ 5   â”‚ boxMoving.q         â”‚ SArray{Tuple{4},Float64,1,4} â”‚         â”‚
â”‚ 6   â”‚ boxMoving.derq      â”‚ SArray{Tuple{4},Float64,1,4} â”‚ 1/s     â”‚
â”‚ 7   â”‚ boxMoving.w         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ rad/s   â”‚
â”‚ 8   â”‚ boxMoving.z         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ rad/s^2 â”‚
â”‚ 9   â”‚ boxMoving.residue_w â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 10  â”‚ boxMoving.residue_f â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 11  â”‚ boxMoving.residue_t â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 12  â”‚ boxMoving.residue_q â”‚ Float64                      â”‚         â”‚


x vector: 
â”‚ Row â”‚ x        â”‚ name        â”‚ fixed â”‚ start                â”‚
â”‚     â”‚ Symbol   â”‚ Symbol      â”‚ Bool  â”‚ Unionâ€¦               â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1:3]   â”‚ boxMoving.r â”‚ 1     â”‚ [1.0, 0.0, 0.15]     â”‚
â”‚ 2   â”‚ x[4:6]   â”‚ boxMoving.v â”‚ 1     â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 3   â”‚ x[7:10]  â”‚ boxMoving.q â”‚ 0     â”‚ [0.0, 0.0, 0.0, 1.0] â”‚
â”‚ 4   â”‚ x[11:13] â”‚ boxMoving.w â”‚ 1     â”‚ [0.0, 0.0, 0.0]      â”‚


copy to variables: 
â”‚ Row â”‚ source      â”‚ target         â”‚
â”‚     â”‚ Symbol      â”‚ Symbol         â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1:3]      â”‚ boxMoving.r    â”‚
â”‚ 2   â”‚ x[4:6]      â”‚ boxMoving.v    â”‚
â”‚ 3   â”‚ x[7:10]     â”‚ boxMoving.q    â”‚
â”‚ 4   â”‚ x[11:13]    â”‚ boxMoving.w    â”‚
â”‚ 5   â”‚ derx[4:6]   â”‚ boxMoving.a    â”‚
â”‚ 6   â”‚ derx[7:10]  â”‚ boxMoving.derq â”‚
â”‚ 7   â”‚ derx[11:13] â”‚ boxMoving.z    â”‚


copy to residue vector: 
â”‚ Row â”‚ source                  â”‚ target         â”‚
â”‚     â”‚ Symbol                  â”‚ Symbol         â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ derx[1:3] - boxMoving.v â”‚ residue[1:3]   â”‚
â”‚ 2   â”‚ boxMoving.residue_w     â”‚ residue[4:6]   â”‚
â”‚ 3   â”‚ boxMoving.residue_f     â”‚ residue[7:9]   â”‚
â”‚ 4   â”‚ boxMoving.residue_t     â”‚ residue[10:12] â”‚
â”‚ 5   â”‚ boxMoving.residue_q     â”‚ residue[13]    â”‚


copy to results: 
â”‚ Row â”‚ source         â”‚ target        â”‚ start                â”‚
â”‚     â”‚ Symbol         â”‚ Symbol        â”‚ Unionâ€¦               â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time           â”‚ result[1]     â”‚ 0.0                  â”‚
â”‚ 2   â”‚ boxMoving.r    â”‚ result[2:4]   â”‚ [1.0, 0.0, 0.15]     â”‚
â”‚ 3   â”‚ boxMoving.v    â”‚ result[5:7]   â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 4   â”‚ boxMoving.a    â”‚ result[8:10]  â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 5   â”‚ boxMoving.q    â”‚ result[11:14] â”‚ [0.0, 0.0, 0.0, 1.0] â”‚
â”‚ 6   â”‚ boxMoving.derq â”‚ result[15:18] â”‚ [0.0, 0.0, 0.0, 0.0] â”‚
â”‚ 7   â”‚ boxMoving.w    â”‚ result[19:21] â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 8   â”‚ boxMoving.z    â”‚ result[22:24] â”‚ [0.0, 0.0, 0.0]      â”‚
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: ThreeDFiles
      Initialization at time = 0.0 s
        initial values:
          â”‚ x  â”‚ name           â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1  â”‚ boxMoving.r[1] â”‚ 1.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2  â”‚ boxMoving.r[2] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 3  â”‚ boxMoving.r[3] â”‚ 0.15    â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 4  â”‚ boxMoving.v[1] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 5  â”‚ boxMoving.v[2] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 6  â”‚ boxMoving.v[3] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 7  â”‚ boxMoving.q[1] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 8  â”‚ boxMoving.q[2] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 9  â”‚ boxMoving.q[3] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 10 â”‚ boxMoving.q[4] â”‚ 1.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 11 â”‚ boxMoving.w[1] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 12 â”‚ boxMoving.w[2] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 13 â”‚ boxMoving.w[3] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
      Simulation started

      Simulation is terminated at time = 2.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.21 s (init: 0.0022 s, integration: 0.21 s)
        startTime      = 0.0 s
        stopTime       = 2.0 s
        interval       = 0.001 s
        tolerance      = 1.0e-8
        nEquations     = 13 (includes 1 constraints)
        nResults       = 2001
        nSteps         = 22
        nResidues      = 282 (includes residue calls for Jacobian)
        nZeroCrossings = 2022
        nJac           = 20
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 0
        h0             = 1e-06 s
        hMin           = 1e-06 s
        hMax           = 0.95 s
        orderMax       = 2
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of contactForceLaw_2_boxes.jl!


variables: . Omitted printing of 9 columns
â”‚ Row â”‚ name          â”‚ ValueType â”‚ unit   â”‚ numericType â”‚ vec     â”‚ vecIndex â”‚
â”‚     â”‚ Symbol        â”‚ Symbol    â”‚ String â”‚ ModiaMatâ€¦   â”‚ Symbol  â”‚ Any      â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time          â”‚ Float64   â”‚ s      â”‚ TIME        â”‚         â”‚ 0        â”‚
â”‚ 2   â”‚ prisX.s       â”‚ Float64   â”‚ m      â”‚ XD_EXP      â”‚ x       â”‚ 1        â”‚
â”‚ 3   â”‚ prisX.v       â”‚ Float64   â”‚ m/s    â”‚ XD_IMP      â”‚ x       â”‚ 4        â”‚
â”‚ 4   â”‚ prisX.a       â”‚ Float64   â”‚ m/s^2  â”‚ DER_XD_IMP  â”‚ derx    â”‚ 4        â”‚
â”‚ 5   â”‚ prisX.f       â”‚ Float64   â”‚ N      â”‚ WR          â”‚         â”‚ 0        â”‚
â”‚ 6   â”‚ prisX.residue â”‚ Float64   â”‚        â”‚ FD_IMP      â”‚ residue â”‚ 4        â”‚
â”‚ 7   â”‚ prisX.P       â”‚ Float64   â”‚ J      â”‚ WC          â”‚         â”‚ 0        â”‚
â‹®
â”‚ 12  â”‚ prisY.residue â”‚ Float64   â”‚        â”‚ FD_IMP      â”‚ residue â”‚ 5        â”‚
â”‚ 13  â”‚ prisY.P       â”‚ Float64   â”‚ J      â”‚ WC          â”‚         â”‚ 0        â”‚
â”‚ 14  â”‚ prisZ.s       â”‚ Float64   â”‚ m      â”‚ XD_EXP      â”‚ x       â”‚ 3        â”‚
â”‚ 15  â”‚ prisZ.v       â”‚ Float64   â”‚ m/s    â”‚ XD_IMP      â”‚ x       â”‚ 6        â”‚
â”‚ 16  â”‚ prisZ.a       â”‚ Float64   â”‚ m/s^2  â”‚ DER_XD_IMP  â”‚ derx    â”‚ 6        â”‚
â”‚ 17  â”‚ prisZ.f       â”‚ Float64   â”‚ N      â”‚ WR          â”‚         â”‚ 0        â”‚
â”‚ 18  â”‚ prisZ.residue â”‚ Float64   â”‚        â”‚ FD_IMP      â”‚ residue â”‚ 6        â”‚
â”‚ 19  â”‚ prisZ.P       â”‚ Float64   â”‚ J      â”‚ WC          â”‚         â”‚ 0        â”‚


x vector: 
â”‚ Row â”‚ x      â”‚ name    â”‚ fixed â”‚ start  â”‚
â”‚     â”‚ Symbol â”‚ Symbol  â”‚ Bool  â”‚ Unionâ€¦ â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1]   â”‚ prisX.s â”‚ 1     â”‚ 0.0    â”‚
â”‚ 2   â”‚ x[2]   â”‚ prisY.s â”‚ 1     â”‚ 0.0    â”‚
â”‚ 3   â”‚ x[3]   â”‚ prisZ.s â”‚ 1     â”‚ 0.0    â”‚
â”‚ 4   â”‚ x[4]   â”‚ prisX.v â”‚ 1     â”‚ -6.0   â”‚
â”‚ 5   â”‚ x[5]   â”‚ prisY.v â”‚ 1     â”‚ 2.0    â”‚
â”‚ 6   â”‚ x[6]   â”‚ prisZ.v â”‚ 1     â”‚ 4.0    â”‚


copy to variables: 
â”‚ Row â”‚ source  â”‚ target  â”‚
â”‚     â”‚ Symbol  â”‚ Symbol  â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1]    â”‚ prisX.s â”‚
â”‚ 2   â”‚ x[2]    â”‚ prisY.s â”‚
â”‚ 3   â”‚ x[3]    â”‚ prisZ.s â”‚
â”‚ 4   â”‚ x[4]    â”‚ prisX.v â”‚
â”‚ 5   â”‚ x[5]    â”‚ prisY.v â”‚
â”‚ 6   â”‚ x[6]    â”‚ prisZ.v â”‚
â”‚ 7   â”‚ derx[4] â”‚ prisX.a â”‚
â”‚ 8   â”‚ derx[5] â”‚ prisY.a â”‚
â”‚ 9   â”‚ derx[6] â”‚ prisZ.a â”‚


copy to residue vector: 
â”‚ Row â”‚ source            â”‚ target     â”‚
â”‚     â”‚ Symbol            â”‚ Symbol     â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ derx[1] - prisX.v â”‚ residue[1] â”‚
â”‚ 2   â”‚ derx[2] - prisY.v â”‚ residue[2] â”‚
â”‚ 3   â”‚ derx[3] - prisZ.v â”‚ residue[3] â”‚
â”‚ 4   â”‚ prisX.residue     â”‚ residue[4] â”‚
â”‚ 5   â”‚ prisY.residue     â”‚ residue[5] â”‚
â”‚ 6   â”‚ prisZ.residue     â”‚ residue[6] â”‚


copy to results: 
â”‚ Row â”‚ source  â”‚ target     â”‚ start  â”‚
â”‚     â”‚ Symbol  â”‚ Symbol     â”‚ Unionâ€¦ â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time    â”‚ result[1]  â”‚ 0.0    â”‚
â”‚ 2   â”‚ prisX.s â”‚ result[2]  â”‚ 0.0    â”‚
â”‚ 3   â”‚ prisX.v â”‚ result[3]  â”‚ -6.0   â”‚
â”‚ 4   â”‚ prisX.a â”‚ result[4]  â”‚ 0.0    â”‚
â”‚ 5   â”‚ prisX.f â”‚ result[5]  â”‚ 0.0    â”‚
â”‚ 6   â”‚ prisX.P â”‚ result[6]  â”‚ 0.0    â”‚
â”‚ 7   â”‚ prisY.s â”‚ result[7]  â”‚ 0.0    â”‚
â”‚ 8   â”‚ prisY.v â”‚ result[8]  â”‚ 2.0    â”‚
â”‚ 9   â”‚ prisY.a â”‚ result[9]  â”‚ 0.0    â”‚
â”‚ 10  â”‚ prisY.f â”‚ result[10] â”‚ 0.0    â”‚
â”‚ 11  â”‚ prisY.P â”‚ result[11] â”‚ 0.0    â”‚
â”‚ 12  â”‚ prisZ.s â”‚ result[12] â”‚ 0.0    â”‚
â”‚ 13  â”‚ prisZ.v â”‚ result[13] â”‚ 4.0    â”‚
â”‚ 14  â”‚ prisZ.a â”‚ result[14] â”‚ 0.0    â”‚
â”‚ 15  â”‚ prisZ.f â”‚ result[15] â”‚ 0.0    â”‚
â”‚ 16  â”‚ prisZ.P â”‚ result[16] â”‚ 0.0    â”‚
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of contactForceLaw_2_boxes_Prismatic.jl!


variables: . Omitted printing of 12 columns
â”‚ Row â”‚ name                    â”‚ ValueType                    â”‚ unit    â”‚
â”‚     â”‚ Symbol                  â”‚ Symbol                       â”‚ String  â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time                    â”‚ Float64                      â”‚ s       â”‚
â”‚ 2   â”‚ boxMoving.box.r         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m       â”‚
â”‚ 3   â”‚ boxMoving.box.v         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m/s     â”‚
â”‚ 4   â”‚ boxMoving.box.a         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m/s^2   â”‚
â”‚ 5   â”‚ boxMoving.box.q         â”‚ SArray{Tuple{4},Float64,1,4} â”‚         â”‚
â”‚ 6   â”‚ boxMoving.box.derq      â”‚ SArray{Tuple{4},Float64,1,4} â”‚ 1/s     â”‚
â”‚ 7   â”‚ boxMoving.box.w         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ rad/s   â”‚
â”‚ 8   â”‚ boxMoving.box.z         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ rad/s^2 â”‚
â”‚ 9   â”‚ boxMoving.box.residue_w â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 10  â”‚ boxMoving.box.residue_f â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 11  â”‚ boxMoving.box.residue_t â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 12  â”‚ boxMoving.box.residue_q â”‚ Float64                      â”‚         â”‚


x vector: 
â”‚ Row â”‚ x        â”‚ name            â”‚ fixed â”‚ start                â”‚
â”‚     â”‚ Symbol   â”‚ Symbol          â”‚ Bool  â”‚ Unionâ€¦               â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1:3]   â”‚ boxMoving.box.r â”‚ 1     â”‚ [0.3, 0.3, 0.4]      â”‚
â”‚ 2   â”‚ x[4:6]   â”‚ boxMoving.box.v â”‚ 1     â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 3   â”‚ x[7:10]  â”‚ boxMoving.box.q â”‚ 0     â”‚ [0.0, 0.0, 0.0, 1.0] â”‚
â”‚ 4   â”‚ x[11:13] â”‚ boxMoving.box.w â”‚ 1     â”‚ [0.0, 0.0, 0.0]      â”‚


copy to variables: 
â”‚ Row â”‚ source      â”‚ target             â”‚
â”‚     â”‚ Symbol      â”‚ Symbol             â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1:3]      â”‚ boxMoving.box.r    â”‚
â”‚ 2   â”‚ x[4:6]      â”‚ boxMoving.box.v    â”‚
â”‚ 3   â”‚ x[7:10]     â”‚ boxMoving.box.q    â”‚
â”‚ 4   â”‚ x[11:13]    â”‚ boxMoving.box.w    â”‚
â”‚ 5   â”‚ derx[4:6]   â”‚ boxMoving.box.a    â”‚
â”‚ 6   â”‚ derx[7:10]  â”‚ boxMoving.box.derq â”‚
â”‚ 7   â”‚ derx[11:13] â”‚ boxMoving.box.z    â”‚


copy to residue vector: 
â”‚ Row â”‚ source                      â”‚ target         â”‚
â”‚     â”‚ Symbol                      â”‚ Symbol         â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ derx[1:3] - boxMoving.box.v â”‚ residue[1:3]   â”‚
â”‚ 2   â”‚ boxMoving.box.residue_w     â”‚ residue[4:6]   â”‚
â”‚ 3   â”‚ boxMoving.box.residue_f     â”‚ residue[7:9]   â”‚
â”‚ 4   â”‚ boxMoving.box.residue_t     â”‚ residue[10:12] â”‚
â”‚ 5   â”‚ boxMoving.box.residue_q     â”‚ residue[13]    â”‚


copy to results: 
â”‚ Row â”‚ source             â”‚ target        â”‚ start                â”‚
â”‚     â”‚ Symbol             â”‚ Symbol        â”‚ Unionâ€¦               â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time               â”‚ result[1]     â”‚ 0.0                  â”‚
â”‚ 2   â”‚ boxMoving.box.r    â”‚ result[2:4]   â”‚ [0.3, 0.3, 0.4]      â”‚
â”‚ 3   â”‚ boxMoving.box.v    â”‚ result[5:7]   â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 4   â”‚ boxMoving.box.a    â”‚ result[8:10]  â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 5   â”‚ boxMoving.box.q    â”‚ result[11:14] â”‚ [0.0, 0.0, 0.0, 1.0] â”‚
â”‚ 6   â”‚ boxMoving.box.derq â”‚ result[15:18] â”‚ [0.0, 0.0, 0.0, 0.0] â”‚
â”‚ 7   â”‚ boxMoving.box.w    â”‚ result[19:21] â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 8   â”‚ boxMoving.box.z    â”‚ result[22:24] â”‚ [0.0, 0.0, 0.0]      â”‚
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: ThreeDFiles
      Initialization at time = 0.0 s
        initial values:
          â”‚ x  â”‚ name               â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1  â”‚ boxMoving.box.r[1] â”‚ 0.3     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2  â”‚ boxMoving.box.r[2] â”‚ 0.3     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 3  â”‚ boxMoving.box.r[3] â”‚ 0.4     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 4  â”‚ boxMoving.box.v[1] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 5  â”‚ boxMoving.box.v[2] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 6  â”‚ boxMoving.box.v[3] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 7  â”‚ boxMoving.box.q[1] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 8  â”‚ boxMoving.box.q[2] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 9  â”‚ boxMoving.box.q[3] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 10 â”‚ boxMoving.box.q[4] â”‚ 1.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 11 â”‚ boxMoving.box.w[1] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 12 â”‚ boxMoving.box.w[2] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 13 â”‚ boxMoving.box.w[3] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
      Simulation started

      State event (zero-crossing) at time = 0.24731005616100146 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -2.000004734248911e-8 became < 0
            contact normal = [-2.26e-06,-1.71e-06,1], contact position = [0.201,0.201,-8.94e-07], c_res=6.55e+09, d_res=0.44
        distance(box,boxMoving.ball7) = -2.0000047342488728e-8 became < 0
            contact normal = [1.71e-06,-2.26e-06,1], contact position = [0.399,0.201,-8.94e-07], c_res=6.55e+09, d_res=0.44
        distance(box,boxMoving.ball6) = -2.0000047342489152e-8 became < 0
            contact normal = [-1.71e-06,2.26e-06,1], contact position = [0.201,0.399,-8.94e-07], c_res=6.55e+09, d_res=0.44
        distance(box,boxMoving.ball5) = -2.0000047342488728e-8 became < 0
            contact normal = [2.26e-06,1.71e-06,1], contact position = [0.399,0.399,-8.94e-07], c_res=6.55e+09, d_res=0.44
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.24811256605713514 s (z[1] > 0)
        distance(box,boxMoving.ball8)  became > 0
        distance(box,boxMoving.ball7)  became > 0
        distance(box,boxMoving.ball6)  became > 0
        distance(box,boxMoving.ball5)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.5331965875313578 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -2.0000053829714512e-8 became < 0
            contact normal = [-2.24e-06,-4.19e-07,1], contact position = [0.201,0.201,-8.29e-07], c_res=6.55e+09, d_res=0.763
        distance(box,boxMoving.ball7) = -2.0000052961080954e-8 became < 0
            contact normal = [4.19e-07,-2.24e-06,1], contact position = [0.399,0.201,-8.29e-07], c_res=6.55e+09, d_res=0.763
        distance(box,boxMoving.ball6) = -2.000005323904371e-8 became < 0
            contact normal = [-4.19e-07,2.24e-06,1], contact position = [0.201,0.399,-8.29e-07], c_res=6.55e+09, d_res=0.763
        distance(box,boxMoving.ball5) = -2.0000052370410364e-8 became < 0
            contact normal = [2.24e-06,4.19e-07,1], contact position = [0.399,0.399,-8.29e-07], c_res=6.55e+09, d_res=0.763
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.5340932462934279 s (z[1] > 0)
        distance(box,boxMoving.ball8)  became > 0
        distance(box,boxMoving.ball7)  became > 0
        distance(box,boxMoving.ball6)  became > 0
        distance(box,boxMoving.ball5)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.6981642429215671 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -1.99997494879268e-8 became < 0
            contact normal = [-2.24e-06,-4.19e-07,1], contact position = [0.201,0.201,-8.29e-07], c_res=6.55e+09, d_res=1.33
        distance(box,boxMoving.ball7) = -1.999990914271078e-8 became < 0
            contact normal = [4.19e-07,-2.24e-06,1], contact position = [0.399,0.201,-8.29e-07], c_res=6.55e+09, d_res=1.33
        distance(box,boxMoving.ball6) = -1.99998613331054e-8 became < 0
            contact normal = [-4.19e-07,2.24e-06,1], contact position = [0.201,0.399,-8.29e-07], c_res=6.55e+09, d_res=1.33
        distance(box,boxMoving.ball5) = -2.000002098788915e-8 became < 0
            contact normal = [2.24e-06,4.19e-07,1], contact position = [0.399,0.399,-8.29e-07], c_res=6.55e+09, d_res=1.33
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.6991670861029298 s (z[1] > 0)
        distance(box,boxMoving.ball8)  became > 0
        distance(box,boxMoving.ball7)  became > 0
        distance(box,boxMoving.ball6)  became > 0
        distance(box,boxMoving.ball5)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.7933203482723291 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -2.0000015613892785e-8 became < 0
            contact normal = [-2.24e-06,-4.19e-07,1], contact position = [0.201,0.201,-8.29e-07], c_res=6.55e+09, d_res=2.31
        distance(box,boxMoving.ball7) = -1.998535284357674e-8 became < 0
            contact normal = [4.19e-07,-2.24e-06,1], contact position = [0.399,0.201,-8.29e-07], c_res=6.55e+09, d_res=2.31
        distance(box,boxMoving.ball6) = -1.9989737847527275e-8 became < 0
            contact normal = [-4.19e-07,2.24e-06,1], contact position = [0.201,0.399,-8.29e-07], c_res=6.55e+09, d_res=2.31
        distance(box,boxMoving.ball5) = -1.997507507793743e-8 became < 0
            contact normal = [2.24e-06,4.19e-07,1], contact position = [0.399,0.399,-8.29e-07], c_res=6.55e+09, d_res=2.31
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.7944441334050762 s (z[1] > 0)
        distance(box,boxMoving.ball8)  became > 0
        distance(box,boxMoving.ball7)  became > 0
        distance(box,boxMoving.ball6)  became > 0
        distance(box,boxMoving.ball5)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8481667628460017 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -1.8883445996158144e-8 became < 0
            contact normal = [-2.24e-06,-4.19e-07,1], contact position = [0.201,0.201,-8.29e-07], c_res=6.55e+09, d_res=4.05
        distance(box,boxMoving.ball7) = -1.9539959612297196e-8 became < 0
            contact normal = [4.19e-07,-2.24e-06,1], contact position = [0.399,0.201,-8.29e-07], c_res=6.55e+09, d_res=4.05
        distance(box,boxMoving.ball6) = -1.934348639361537e-8 became < 0
            contact normal = [-4.19e-07,2.24e-06,1], contact position = [0.201,0.399,-8.29e-07], c_res=6.55e+09, d_res=4.05
        distance(box,boxMoving.ball5) = -2.000000000997641e-8 became < 0
            contact normal = [2.24e-06,4.19e-07,1], contact position = [0.399,0.399,-8.29e-07], c_res=6.55e+09, d_res=4.05
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8494309894541551 s (z[1] > 0)
        distance(box,boxMoving.ball8)  became > 0
        distance(box,boxMoving.ball7)  became > 0
        distance(box,boxMoving.ball6)  became > 0
        distance(box,boxMoving.ball5)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8797327057462421 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -2.0000003745970735e-8 became < 0
            contact normal = [-2.24e-06,-4.19e-07,1], contact position = [0.201,0.201,-8.29e-07], c_res=6.55e+09, d_res=7.18
        distance(box,boxMoving.ball6) = -1.0459061757832709e-8 became < 0
            contact normal = [-4.19e-07,2.24e-06,1], contact position = [0.201,0.399,-8.3e-07], c_res=6.55e+09, d_res=7.18
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8797327423379592 s (z[2] < 0)
        distance(box,boxMoving.ball7) = -2.0000001670920564e-8 became < 0
            contact normal = [4.19e-07,-2.24e-06,1], contact position = [0.399,0.201,-8.29e-07], c_res=6.55e+09, d_res=7.18
        distance(box,boxMoving.ball5) = -1.0459048553617148e-8 became < 0
            contact normal = [2.24e-06,4.19e-07,1], contact position = [0.399,0.399,-8.3e-07], c_res=6.55e+09, d_res=7.18
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8811664556201371 s (z[1] > 0)
        distance(box,boxMoving.ball8)  became > 0
        distance(box,boxMoving.ball7)  became > 0
        distance(box,boxMoving.ball6)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8811665291739674 s (z[1] > 0)
        distance(box,boxMoving.ball5)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.897846101807413 s (z[2] < 0)
        distance(box,boxMoving.ball5) = -2.0000000048200546e-8 became < 0
            contact normal = [2.24e-06,4.19e-07,1], contact position = [0.399,0.399,-8.29e-07], c_res=6.55e+09, d_res=13
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.897846521658391 s (z[2] < 0)
        distance(box,boxMoving.ball7) = -2.0000002037924482e-8 became < 0
            contact normal = [4.19e-07,-2.24e-06,1], contact position = [0.399,0.201,-8.29e-07], c_res=6.55e+09, d_res=13
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.897846688366854 s (z[2] < 0)
        distance(box,boxMoving.ball6) = -2.0000000019300827e-8 became < 0
            contact normal = [-4.19e-07,2.24e-06,1], contact position = [0.201,0.399,-8.29e-07], c_res=6.55e+09, d_res=13
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.897847108215627 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -2.0000000001535516e-8 became < 0
            contact normal = [-2.24e-06,-4.19e-07,1], contact position = [0.201,0.201,-8.29e-07], c_res=6.55e+09, d_res=13
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8995017209267455 s (z[1] > 0)
        distance(box,boxMoving.ball5)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.899502191694332 s (z[1] > 0)
        distance(box,boxMoving.ball7)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8995023786988657 s (z[1] > 0)
        distance(box,boxMoving.ball6)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.8995028498622012 s (z[1] > 0)
        distance(box,boxMoving.ball8)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9081743942656031 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -2.0000000006496667e-8 became < 0
            contact normal = [-2.24e-06,-4.19e-07,1], contact position = [0.201,0.201,-8.29e-07], c_res=6.55e+09, d_res=25.1
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9081770025016611 s (z[2] < 0)
        distance(box,boxMoving.ball6) = -2.0000000999894648e-8 became < 0
            contact normal = [-4.19e-07,2.24e-06,1], contact position = [0.201,0.399,-8.29e-07], c_res=6.55e+09, d_res=25.1
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9081780402316431 s (z[2] < 0)
        distance(box,boxMoving.ball7) = -2.0000000008288274e-8 became < 0
            contact normal = [4.19e-07,-2.24e-06,1], contact position = [0.399,0.201,-8.29e-07], c_res=6.55e+09, d_res=25.1
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.908180648058715 s (z[2] < 0)
        distance(box,boxMoving.ball5) = -2.000000004206774e-8 became < 0
            contact normal = [2.24e-06,4.19e-07,1], contact position = [0.399,0.399,-8.29e-07], c_res=6.55e+09, d_res=25.1
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9101822686296175 s (z[1] > 0)
        distance(box,boxMoving.ball8)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9101850147858086 s (z[1] > 0)
        distance(box,boxMoving.ball6)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9101861105321242 s (z[1] > 0)
        distance(box,boxMoving.ball7)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9101888658787634 s (z[1] > 0)
        distance(box,boxMoving.ball5)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9139767373085492 s (z[2] < 0)
        distance(box,boxMoving.ball5) = -2.0000000462887545e-8 became < 0
            contact normal = [2.24e-06,4.19e-07,1], contact position = [0.399,0.399,-8.29e-07], c_res=6.55e+09, d_res=57.4
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9139812754703438 s (z[2] < 0)
        distance(box,boxMoving.ball7) = -2.0000000005997262e-8 became < 0
            contact normal = [4.19e-07,-2.24e-06,1], contact position = [0.399,0.201,-8.29e-07], c_res=6.55e+09, d_res=57.3
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9139830822267071 s (z[2] < 0)
        distance(box,boxMoving.ball6) = -2.0000000015733627e-8 became < 0
            contact normal = [-4.19e-07,2.24e-06,1], contact position = [0.201,0.399,-8.29e-07], c_res=6.55e+09, d_res=57.3
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.9139876111404962 s (z[2] < 0)
        distance(box,boxMoving.ball8) = -2.0000000505773465e-8 became < 0
            contact normal = [-2.24e-06,-4.19e-07,1], contact position = [0.201,0.201,-8.29e-07], c_res=6.55e+09, d_res=57.2
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      Simulation is terminated at time = 2.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 1.8 s (init: 0.0015 s, integration: 1.7 s)
        startTime      = 0.0 s
        stopTime       = 2.0 s
        interval       = 0.001 s
        tolerance      = 1.0e-8
        nEquations     = 13 (includes 1 constraints)
        nResults       = 2069
        nSteps         = 2749
        nResidues      = 12026 (includes residue calls for Jacobian)
        nZeroCrossings = 5036
        nJac           = 631
        nTimeEvents    = 0
        nStateEvents   = 34
        nRestartEvents = 34
        nErrTestFails  = 99
        h0             = 1.8e-10 s
        hMin           = 1.8e-10 s
        hMax           = 0.44 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of contactForceLaw_2_boxes2.jl!
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: ThreeDFiles
      Initialization at time = 0.0 s
        initial values:
          â”‚ x  â”‚ name              â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1  â”‚ sphereMoving.r[1] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2  â”‚ sphereMoving.r[2] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 3  â”‚ sphereMoving.r[3] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 4  â”‚ sphereMoving.v[1] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 5  â”‚ sphereMoving.v[2] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 6  â”‚ sphereMoving.v[3] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 7  â”‚ sphereMoving.q[1] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 8  â”‚ sphereMoving.q[2] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 9  â”‚ sphereMoving.q[3] â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 10 â”‚ sphereMoving.q[4] â”‚ 1.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 11 â”‚ sphereMoving.w[1] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 12 â”‚ sphereMoving.w[2] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 13 â”‚ sphereMoving.w[3] â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
      Simulation started

      State event (zero-crossing) at time = 0.6772856461815322 s (z[2] < 0)
        distance(box,sphereMoving) = -2.000000010322145e-8 became < 0
            contact normal = [1,3.29e-07,6.38e-08], contact position = [-2.5,-8.23e-08,-1.59e-08], c_res=1.1e+11, d_res=0.103
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 0.6805673217160505 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 1.604523787030293 s (z[2] < 0)
        distance(box,sphereMoving) = -2.0000000015017868e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,1.31e-06,2.28e-07], c_res=1.1e+11, d_res=0.151
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 1.6080679141645005 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 2.2377169757480853 s (z[2] < 0)
        distance(box,sphereMoving) = -2.000000006593378e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,1.86e-06,5.39e-07], c_res=1.1e+11, d_res=0.222
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 2.2415470428594424 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 2.6700005061182654 s (z[2] < 0)
        distance(box,sphereMoving) = -2.000001605328688e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.12e-06,6.87e-07], c_res=1.1e+11, d_res=0.326
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 2.674142993270264 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 2.9650010951552574 s (z[2] < 0)
        distance(box,sphereMoving) = -2.0000011286650343e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.26e-06,7.61e-07], c_res=1.1e+11, d_res=0.481
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 2.9694874245664495 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.166184348804458 s (z[2] < 0)
        distance(box,sphereMoving) = -2.000000008377676e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.33e-06,8.01e-07], c_res=1.1e+11, d_res=0.711
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.171053554394586 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.3032418222143822 s (z[2] < 0)
        distance(box,sphereMoving) = -2.0000000035369135e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.37e-06,8.24e-07], c_res=1.1e+11, d_res=1.06
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.3085455321837167 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.396454112727742 s (z[2] < 0)
        distance(box,sphereMoving) = -2.000000324163616e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.39e-06,8.38e-07], c_res=1.1e+11, d_res=1.59
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.402266590729442 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.4596696774585123 s (z[2] < 0)
        distance(box,sphereMoving) = -2.0000001717996415e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.41e-06,8.48e-07], c_res=1.1e+11, d_res=2.44
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.4661106876106125 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.5023370104431364 s (z[2] < 0)
        distance(box,sphereMoving) = -2.000000009343195e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.42e-06,8.53e-07], c_res=1.1e+11, d_res=3.86
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.509635205421355 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.530883435301823 s (z[2] < 0)
        distance(box,sphereMoving) = -2.000000010247696e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.43e-06,8.57e-07], c_res=1.1e+11, d_res=6.58
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.539642177740478 s (z[1] > 0)
        distance(box,sphereMoving)  became > 0
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      State event (zero-crossing) at time = 3.5495897320386813 s (z[2] < 0)
        distance(box,sphereMoving) = -2.000000030575503e-8 became < 0
            contact normal = [1,2.82e-07,1.59e-07], contact position = [-2.5,2.43e-06,8.6e-07], c_res=1.1e+11, d_res=14.1
        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
        restart = Restart

      Simulation is terminated at time = 6.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 1.4 s (init: 0.0017 s, integration: 1.4 s)
        startTime      = 0.0 s
        stopTime       = 6.0 s
        interval       = 0.001 s
        tolerance      = 1.0e-8
        nEquations     = 13 (includes 1 constraints)
        nResults       = 6047
        nSteps         = 3729
        nResidues      = 14105 (includes residue calls for Jacobian)
        nZeroCrossings = 9935
        nJac           = 653
        nTimeEvents    = 0
        nStateEvents   = 23
        nRestartEvents = 23
        nErrTestFails  = 130
        h0             = 1.8e-10 s
        hMin           = 1.8e-10 s
        hMax           = 0.89 s
        orderMax       = 5
        sparseSolver   = false
... success of contactForceLaw_Ball.jl!
... success of contactForceLaw_ballWithBall.jl!


variables: . Omitted printing of 12 columns
â”‚ Row â”‚ name                   â”‚ ValueType                    â”‚ unit    â”‚
â”‚     â”‚ Symbol                 â”‚ Symbol                       â”‚ String  â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time                   â”‚ Float64                      â”‚ s       â”‚
â”‚ 2   â”‚ sphereMoving.r         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m       â”‚
â”‚ 3   â”‚ sphereMoving.v         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m/s     â”‚
â”‚ 4   â”‚ sphereMoving.a         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ m/s^2   â”‚
â”‚ 5   â”‚ sphereMoving.q         â”‚ SArray{Tuple{4},Float64,1,4} â”‚         â”‚
â”‚ 6   â”‚ sphereMoving.derq      â”‚ SArray{Tuple{4},Float64,1,4} â”‚ 1/s     â”‚
â”‚ 7   â”‚ sphereMoving.w         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ rad/s   â”‚
â”‚ 8   â”‚ sphereMoving.z         â”‚ SArray{Tuple{3},Float64,1,3} â”‚ rad/s^2 â”‚
â”‚ 9   â”‚ sphereMoving.residue_w â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 10  â”‚ sphereMoving.residue_f â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 11  â”‚ sphereMoving.residue_t â”‚ SArray{Tuple{3},Float64,1,3} â”‚         â”‚
â”‚ 12  â”‚ sphereMoving.residue_q â”‚ Float64                      â”‚         â”‚


x vector: 
â”‚ Row â”‚ x        â”‚ name           â”‚ fixed â”‚ start                â”‚
â”‚     â”‚ Symbol   â”‚ Symbol         â”‚ Bool  â”‚ Unionâ€¦               â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1:3]   â”‚ sphereMoving.r â”‚ 1     â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 2   â”‚ x[4:6]   â”‚ sphereMoving.v â”‚ 1     â”‚ [2.0, 0.0, -3.0]     â”‚
â”‚ 3   â”‚ x[7:10]  â”‚ sphereMoving.q â”‚ 0     â”‚ [0.0, 0.0, 0.0, 1.0] â”‚
â”‚ 4   â”‚ x[11:13] â”‚ sphereMoving.w â”‚ 1     â”‚ [0.0, 0.0, 0.0]      â”‚


copy to variables: 
â”‚ Row â”‚ source      â”‚ target            â”‚
â”‚     â”‚ Symbol      â”‚ Symbol            â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1:3]      â”‚ sphereMoving.r    â”‚
â”‚ 2   â”‚ x[4:6]      â”‚ sphereMoving.v    â”‚
â”‚ 3   â”‚ x[7:10]     â”‚ sphereMoving.q    â”‚
â”‚ 4   â”‚ x[11:13]    â”‚ sphereMoving.w    â”‚
â”‚ 5   â”‚ derx[4:6]   â”‚ sphereMoving.a    â”‚
â”‚ 6   â”‚ derx[7:10]  â”‚ sphereMoving.derq â”‚
â”‚ 7   â”‚ derx[11:13] â”‚ sphereMoving.z    â”‚


copy to residue vector: 
â”‚ Row â”‚ source                     â”‚ target         â”‚
â”‚     â”‚ Symbol                     â”‚ Symbol         â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ derx[1:3] - sphereMoving.v â”‚ residue[1:3]   â”‚
â”‚ 2   â”‚ sphereMoving.residue_w     â”‚ residue[4:6]   â”‚
â”‚ 3   â”‚ sphereMoving.residue_f     â”‚ residue[7:9]   â”‚
â”‚ 4   â”‚ sphereMoving.residue_t     â”‚ residue[10:12] â”‚
â”‚ 5   â”‚ sphereMoving.residue_q     â”‚ residue[13]    â”‚


copy to results: 
â”‚ Row â”‚ source            â”‚ target        â”‚ start                â”‚
â”‚     â”‚ Symbol            â”‚ Symbol        â”‚ Unionâ€¦               â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time              â”‚ result[1]     â”‚ 0.0                  â”‚
â”‚ 2   â”‚ sphereMoving.r    â”‚ result[2:4]   â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 3   â”‚ sphereMoving.v    â”‚ result[5:7]   â”‚ [2.0, 0.0, -3.0]     â”‚
â”‚ 4   â”‚ sphereMoving.a    â”‚ result[8:10]  â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 5   â”‚ sphereMoving.q    â”‚ result[11:14] â”‚ [0.0, 0.0, 0.0, 1.0] â”‚
â”‚ 6   â”‚ sphereMoving.derq â”‚ result[15:18] â”‚ [0.0, 0.0, 0.0, 0.0] â”‚
â”‚ 7   â”‚ sphereMoving.w    â”‚ result[19:21] â”‚ [0.0, 0.0, 0.0]      â”‚
â”‚ 8   â”‚ sphereMoving.z    â”‚ result[22:24] â”‚ [0.0, 0.0, 0.0]      â”‚
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of contactForceLaw_ballWithBox_45Deg.jl!


variables: . Omitted printing of 9 columns
â”‚ Row â”‚ name          â”‚ ValueType â”‚ unit   â”‚ numericType â”‚ vec     â”‚ vecIndex â”‚
â”‚     â”‚ Symbol        â”‚ Symbol    â”‚ String â”‚ ModiaMatâ€¦   â”‚ Symbol  â”‚ Any      â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time          â”‚ Float64   â”‚ s      â”‚ TIME        â”‚         â”‚ 0        â”‚
â”‚ 2   â”‚ prisX.s       â”‚ Float64   â”‚ m      â”‚ XD_EXP      â”‚ x       â”‚ 1        â”‚
â”‚ 3   â”‚ prisX.v       â”‚ Float64   â”‚ m/s    â”‚ XD_IMP      â”‚ x       â”‚ 4        â”‚
â”‚ 4   â”‚ prisX.a       â”‚ Float64   â”‚ m/s^2  â”‚ DER_XD_IMP  â”‚ derx    â”‚ 4        â”‚
â”‚ 5   â”‚ prisX.f       â”‚ Float64   â”‚ N      â”‚ WR          â”‚         â”‚ 0        â”‚
â”‚ 6   â”‚ prisX.residue â”‚ Float64   â”‚        â”‚ FD_IMP      â”‚ residue â”‚ 4        â”‚
â”‚ 7   â”‚ prisX.P       â”‚ Float64   â”‚ J      â”‚ WC          â”‚         â”‚ 0        â”‚
â‹®
â”‚ 12  â”‚ prisY.residue â”‚ Float64   â”‚        â”‚ FD_IMP      â”‚ residue â”‚ 5        â”‚
â”‚ 13  â”‚ prisY.P       â”‚ Float64   â”‚ J      â”‚ WC          â”‚         â”‚ 0        â”‚
â”‚ 14  â”‚ prisZ.s       â”‚ Float64   â”‚ m      â”‚ XD_EXP      â”‚ x       â”‚ 3        â”‚
â”‚ 15  â”‚ prisZ.v       â”‚ Float64   â”‚ m/s    â”‚ XD_IMP      â”‚ x       â”‚ 6        â”‚
â”‚ 16  â”‚ prisZ.a       â”‚ Float64   â”‚ m/s^2  â”‚ DER_XD_IMP  â”‚ derx    â”‚ 6        â”‚
â”‚ 17  â”‚ prisZ.f       â”‚ Float64   â”‚ N      â”‚ WR          â”‚         â”‚ 0        â”‚
â”‚ 18  â”‚ prisZ.residue â”‚ Float64   â”‚        â”‚ FD_IMP      â”‚ residue â”‚ 6        â”‚
â”‚ 19  â”‚ prisZ.P       â”‚ Float64   â”‚ J      â”‚ WC          â”‚         â”‚ 0        â”‚


x vector: 
â”‚ Row â”‚ x      â”‚ name    â”‚ fixed â”‚ start  â”‚
â”‚     â”‚ Symbol â”‚ Symbol  â”‚ Bool  â”‚ Unionâ€¦ â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1]   â”‚ prisX.s â”‚ 1     â”‚ 0.0    â”‚
â”‚ 2   â”‚ x[2]   â”‚ prisY.s â”‚ 1     â”‚ 0.0    â”‚
â”‚ 3   â”‚ x[3]   â”‚ prisZ.s â”‚ 1     â”‚ 0.0    â”‚
â”‚ 4   â”‚ x[4]   â”‚ prisX.v â”‚ 1     â”‚ 2.0    â”‚
â”‚ 5   â”‚ x[5]   â”‚ prisY.v â”‚ 1     â”‚ 0.0    â”‚
â”‚ 6   â”‚ x[6]   â”‚ prisZ.v â”‚ 1     â”‚ -3.0   â”‚


copy to variables: 
â”‚ Row â”‚ source  â”‚ target  â”‚
â”‚     â”‚ Symbol  â”‚ Symbol  â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ x[1]    â”‚ prisX.s â”‚
â”‚ 2   â”‚ x[2]    â”‚ prisY.s â”‚
â”‚ 3   â”‚ x[3]    â”‚ prisZ.s â”‚
â”‚ 4   â”‚ x[4]    â”‚ prisX.v â”‚
â”‚ 5   â”‚ x[5]    â”‚ prisY.v â”‚
â”‚ 6   â”‚ x[6]    â”‚ prisZ.v â”‚
â”‚ 7   â”‚ derx[4] â”‚ prisX.a â”‚
â”‚ 8   â”‚ derx[5] â”‚ prisY.a â”‚
â”‚ 9   â”‚ derx[6] â”‚ prisZ.a â”‚


copy to residue vector: 
â”‚ Row â”‚ source            â”‚ target     â”‚
â”‚     â”‚ Symbol            â”‚ Symbol     â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ derx[1] - prisX.v â”‚ residue[1] â”‚
â”‚ 2   â”‚ derx[2] - prisY.v â”‚ residue[2] â”‚
â”‚ 3   â”‚ derx[3] - prisZ.v â”‚ residue[3] â”‚
â”‚ 4   â”‚ prisX.residue     â”‚ residue[4] â”‚
â”‚ 5   â”‚ prisY.residue     â”‚ residue[5] â”‚
â”‚ 6   â”‚ prisZ.residue     â”‚ residue[6] â”‚


copy to results: 
â”‚ Row â”‚ source  â”‚ target     â”‚ start  â”‚
â”‚     â”‚ Symbol  â”‚ Symbol     â”‚ Unionâ€¦ â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1   â”‚ time    â”‚ result[1]  â”‚ 0.0    â”‚
â”‚ 2   â”‚ prisX.s â”‚ result[2]  â”‚ 0.0    â”‚
â”‚ 3   â”‚ prisX.v â”‚ result[3]  â”‚ 2.0    â”‚
â”‚ 4   â”‚ prisX.a â”‚ result[4]  â”‚ 0.0    â”‚
â”‚ 5   â”‚ prisX.f â”‚ result[5]  â”‚ 0.0    â”‚
â”‚ 6   â”‚ prisX.P â”‚ result[6]  â”‚ 0.0    â”‚
â”‚ 7   â”‚ prisY.s â”‚ result[7]  â”‚ 0.0    â”‚
â”‚ 8   â”‚ prisY.v â”‚ result[8]  â”‚ 0.0    â”‚
â”‚ 9   â”‚ prisY.a â”‚ result[9]  â”‚ 0.0    â”‚
â”‚ 10  â”‚ prisY.f â”‚ result[10] â”‚ 0.0    â”‚
â”‚ 11  â”‚ prisY.P â”‚ result[11] â”‚ 0.0    â”‚
â”‚ 12  â”‚ prisZ.s â”‚ result[12] â”‚ 0.0    â”‚
â”‚ 13  â”‚ prisZ.v â”‚ result[13] â”‚ -3.0   â”‚
â”‚ 14  â”‚ prisZ.a â”‚ result[14] â”‚ 0.0    â”‚
â”‚ 15  â”‚ prisZ.f â”‚ result[15] â”‚ 0.0    â”‚
â”‚ 16  â”‚ prisZ.P â”‚ result[16] â”‚ 0.0    â”‚
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: TwoBoxes
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name    â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ prisX.s â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2 â”‚ prisY.s â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 3 â”‚ prisZ.s â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 4 â”‚ prisX.v â”‚ 2.0     â”‚ 1     â”‚ 2.0     â”‚
          â”‚ 5 â”‚ prisY.v â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 6 â”‚ prisZ.v â”‚ -3.0    â”‚ 1     â”‚ 3.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      State event (zero-crossing) at time = 0.43731521721763345 s (z[2] < 0)
        distance(box,boxMoving) = -2.0000005749098553e-8 became < 0
            contact normal = [1.72e-08,-7.57e-08,1], contact position = [0.875,1.89e-08,-2.5], c_res=1.1e+11, d_res=0.0941
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      State event (zero-crossing) at time = 0.4425862085910625 s (z[1] > 0)
        distance(box,boxMoving)  became > 0
        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
        restart = Restart

      Simulation is terminated at time = 0.5 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.098 s (init: 0.00091 s, integration: 0.097 s)
        startTime      = 0.0 s
        stopTime       = 0.5 s
        interval       = 0.001 s
        tolerance      = 1.0e-8
        nEquations     = 6 (includes 0 constraints)
        nResults       = 505
        nSteps         = 461
        nResidues      = 1322 (includes residue calls for Jacobian)
        nZeroCrossings = 976
        nJac           = 96
        nTimeEvents    = 0
        nStateEvents   = 2
        nRestartEvents = 2
        nErrTestFails  = 15
        h0             = 3.4e-10 s
        hMin           = 3.4e-10 s
        hMax           = 0.18 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of contactForceLaw_ballWithBox_Prismatic.jl!
... success of contactForceLaw_newtons_cradle.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of BillardBall1_Cushion1_directHit.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of BillardBall1_Cushion4_arbitraryHit.jl!

 ...test_Examples_Collision finished!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_DoublePendulum.jl!
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: DoublePendulumWithDampers
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name     â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ rev1.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2 â”‚ rev2.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 3 â”‚ rev1.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 4 â”‚ rev2.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      Simulation is terminated at time = 5.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.16 s (init: 0.0077 s, integration: 0.16 s)
        startTime      = 0.0 s
        stopTime       = 5.0 s
        interval       = 0.001 s
        tolerance      = 1.0e-6
        nEquations     = 4 (includes 0 constraints)
        nResults       = 5001
        nSteps         = 838
        nResidues      = 1326 (includes residue calls for Jacobian)
        nZeroCrossings = 0
        nJac           = 57
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 20
        h0             = 2.3e-09 s
        hMin           = 2.3e-09 s
        hMax           = 0.021 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_DoublePendulumWithDampers.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_FallingBall1.jl!
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: Pendulum
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name    â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ rev.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2 â”‚ rev.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      Simulation is terminated at time = 4.5 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.038 s (init: 0.00056 s, integration: 0.038 s)
        startTime      = 0.0 s
        stopTime       = 4.5 s
        interval       = 0.002 s
        tolerance      = 1.0e-6
        nEquations     = 2 (includes 0 constraints)
        nResults       = 2251
        nSteps         = 272
        nResidues      = 339 (includes residue calls for Jacobian)
        nZeroCrossings = 0
        nJac           = 26
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 2
        h0             = 5.8e-09 s
        hMin           = 5.8e-09 s
        hMax           = 0.021 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_Pendulum.jl!
WARNING: replacing module Simulate_Pendulum.
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: Pendulum
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name         â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ revolute.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2 â”‚ revolute.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      Simulation is terminated at time = 5.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.041 s (init: 0.00057 s, integration: 0.04 s)
        startTime      = 0.0 s
        stopTime       = 5.0 s
        interval       = 0.002 s
        tolerance      = 1.0e-6
        nEquations     = 2 (includes 0 constraints)
        nResults       = 2501
        nSteps         = 262
        nResidues      = 370 (includes residue calls for Jacobian)
        nZeroCrossings = 0
        nJac           = 22
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 1
        h0             = 8.3e-09 s
        hMin           = 8.3e-09 s
        hMax           = 0.046 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_Pendulum.jl!
WARNING: replacing module Simulate_Pendulum.
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_Pendulum.jl!
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: PendulumWithController
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name    â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ rev.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2 â”‚ c.PI_x  â”‚ 0.0     â”‚ 0     â”‚ 1.0     â”‚
          â”‚ 3 â”‚ rev.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      Simulation is terminated at time = 5.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.087 s (init: 0.023 s, integration: 0.063 s)
        startTime      = 0.0 s
        stopTime       = 5.0 s
        interval       = 0.002 s
        tolerance      = 0.0001
        nEquations     = 3 (includes 0 constraints)
        nResults       = 2501
        nSteps         = 376
        nResidues      = 568 (includes residue calls for Jacobian)
        nZeroCrossings = 0
        nJac           = 25
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 7
        h0             = 7.1e-07 s
        hMin           = 7.1e-07 s
        hMax           = 0.044 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_PendulumWithController.jl!
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: PendulumWithDamper
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name    â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ rev.phi â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚
          â”‚ 2 â”‚ rev.w   â”‚ 0.0     â”‚ 1     â”‚ 1.0     â”‚

        for given x, determine consistent DAE variables der(x) (solving a linear equation system)
      Simulation started

      Simulation is terminated at time = 5.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.013 s (init: 0.008 s, integration: 0.005 s)
        startTime      = 0.0 s
        stopTime       = 5.0 s
        interval       = 0.1 s
        tolerance      = 0.0001
        nEquations     = 2 (includes 0 constraints)
        nResults       = 51
        nSteps         = 136
        nResidues      = 230 (includes residue calls for Jacobian)
        nZeroCrossings = 0
        nJac           = 22
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 7
        h0             = 5.8e-07 s
        hMin           = 5.8e-07 s
        hMax           = 0.085 s
        orderMax       = 5
        sparseSolver   = false
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Simulate_PendulumWithDamper.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Move_DoublePendulum.jl!
... Revolute joint connecting Fourbar.bar3.frame2 with Fourbar.bar2.frame2 is a cut-joint

... Cut-joint fourbar.rev4 pushed on scene.cutJoints vector
... success of Move_FourBar.jl!
... Revolute joint connecting Fourbar2.bar3.frame2 with Fourbar2.bar2.frame2 is a cut-joint

... Cut-joint fourbar.rev4 pushed on scene.cutJoints vector
... ModiaMath.simulate! (version 0.5.2 2019-07-10) to simulate model: Move2
      Initialization at time = 0.0 s
        initial values:
          â”‚ x â”‚ name             â”‚ start   â”‚ fixed â”‚ nominal â”‚
          â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ 1 â”‚ fourbar.rev2.phi â”‚ -1.5708 â”‚ 1     â”‚ 1.5708  â”‚
          â”‚ 2 â”‚ fourbar.rev3.phi â”‚ 1.10715 â”‚ 1     â”‚ 1.10715 â”‚

        determine consistent DAE variables x,der(x) (with analytical integral over time instant)
      Simulation started

      Simulation is terminated at time = 3.0 s

      Statistics (get help with ?ModiaMath.SimulationStatistics):
        structureOfDAE = DAE_LinearDerivativesAndConstraints
        cpuTime        = 0.038 s (init: 0.011 s, integration: 0.028 s)
        startTime      = 0.0 s
        stopTime       = 3.0 s
        interval       = 0.002 s
        tolerance      = 0.0001
        nEquations     = 2 (includes 2 constraints)
        nResults       = 1501
        nSteps         = 112
        nResidues      = 219 (includes residue calls for Jacobian)
        nZeroCrossings = 0
        nJac           = 19
        nTimeEvents    = 0
        nStateEvents   = 0
        nRestartEvents = 0
        nErrTestFails  = 4
        h0             = 2e-06 s
        hMin           = 2e-06 s
        hMax           = 0.056 s
        orderMax       = 5
        sparseSolver   = false
... success of Move_FourBar2.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_SignalAngle.jl!
... ModiaMath.plot(..): Call is ignored, since PyPlot not available.
... success of Test_SignalTorque.jl!
... success of Move_AllVisualObjects.jl!
... success of Move_SolidFileMesh.jl!
... success of Visualize_AllVisualObjects.jl!
... success of Visualize_Assembly.jl!
... success of Visualize_GeometriesWithMaterial.jl!
... success of Visualize_GeometriesWithoutMaterial.jl!
... success of Visualize_SolidFileMesh.jl!
... success of Visualize_Solids.jl!
... success of Visualize_Text.jl!
... success of Visualize_TextFonts.jl!

... success of runexamples.jl

... success of all tests!
Test Summary: | Pass  Total
Test Modia3D  |   57     57
    Testing Modia3D tests passed 
